// Code generated by MockGen. DO NOT EDIT.
// Source: istorage.go

// Package mocks is a generated GoMock package.
package mocks

import (
	context "context"
	reflect "reflect"

	gomock "github.com/golang/mock/gomock"
	models "gitlab.ozon.dev/ninashvl/homework-1/internal/models"
)

// MockIStorage is a mock of IStorage interface.
type MockIStorage struct {
	ctrl     *gomock.Controller
	recorder *MockIStorageMockRecorder
}

// MockIStorageMockRecorder is the mock recorder for MockIStorage.
type MockIStorageMockRecorder struct {
	mock *MockIStorage
}

// NewMockIStorage creates a new mock instance.
func NewMockIStorage(ctrl *gomock.Controller) *MockIStorage {
	mock := &MockIStorage{ctrl: ctrl}
	mock.recorder = &MockIStorageMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockIStorage) EXPECT() *MockIStorageMockRecorder {
	return m.recorder
}

// Add mocks base method.
func (m *MockIStorage) Add(ctx context.Context, userID int64, expense *models.Expense) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Add", ctx, userID, expense)
	ret0, _ := ret[0].(error)
	return ret0
}

// Add indicates an expected call of Add.
func (mr *MockIStorageMockRecorder) Add(ctx, userID, expense interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Add", reflect.TypeOf((*MockIStorage)(nil).Add), ctx, userID, expense)
}

// GetByRange mocks base method.
func (m *MockIStorage) GetByRange(ctx context.Context, userID int64, timeRange int) ([]*models.TotalExpense, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "GetByRange", ctx, userID, timeRange)
	ret0, _ := ret[0].([]*models.TotalExpense)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// GetByRange indicates an expected call of GetByRange.
func (mr *MockIStorageMockRecorder) GetByRange(ctx, userID, timeRange interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetByRange", reflect.TypeOf((*MockIStorage)(nil).GetByRange), ctx, userID, timeRange)
}

// GetCurrency mocks base method.
func (m *MockIStorage) GetCurrency(ctx context.Context, userID int64) (string, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "GetCurrency", ctx, userID)
	ret0, _ := ret[0].(string)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// GetCurrency indicates an expected call of GetCurrency.
func (mr *MockIStorageMockRecorder) GetCurrency(ctx, userID interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetCurrency", reflect.TypeOf((*MockIStorage)(nil).GetCurrency), ctx, userID)
}

// GetLimit mocks base method.
func (m *MockIStorage) GetLimit(ctx context.Context, userID int64) (float64, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "GetLimit", ctx, userID)
	ret0, _ := ret[0].(float64)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// GetLimit indicates an expected call of GetLimit.
func (mr *MockIStorageMockRecorder) GetLimit(ctx, userID interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetLimit", reflect.TypeOf((*MockIStorage)(nil).GetLimit), ctx, userID)
}

// SetCurrency mocks base method.
func (m *MockIStorage) SetCurrency(ctx context.Context, userID int64, curr string) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "SetCurrency", ctx, userID, curr)
	ret0, _ := ret[0].(error)
	return ret0
}

// SetCurrency indicates an expected call of SetCurrency.
func (mr *MockIStorageMockRecorder) SetCurrency(ctx, userID, curr interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "SetCurrency", reflect.TypeOf((*MockIStorage)(nil).SetCurrency), ctx, userID, curr)
}

// SetLimit mocks base method.
func (m *MockIStorage) SetLimit(ctx context.Context, userID int64, limit float64) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "SetLimit", ctx, userID, limit)
	ret0, _ := ret[0].(error)
	return ret0
}

// SetLimit indicates an expected call of SetLimit.
func (mr *MockIStorageMockRecorder) SetLimit(ctx, userID, limit interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "SetLimit", reflect.TypeOf((*MockIStorage)(nil).SetLimit), ctx, userID, limit)
}

// UpdateCurrency mocks base method.
func (m *MockIStorage) UpdateCurrency(ctx context.Context) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "UpdateCurrency", ctx)
	ret0, _ := ret[0].(error)
	return ret0
}

// UpdateCurrency indicates an expected call of UpdateCurrency.
func (mr *MockIStorageMockRecorder) UpdateCurrency(ctx interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "UpdateCurrency", reflect.TypeOf((*MockIStorage)(nil).UpdateCurrency), ctx)
}
